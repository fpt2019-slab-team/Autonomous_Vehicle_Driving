`default_nettype none

module sccb_if
  (
   input wire  clk,         // 24MHz
   input wire  rst,         // active high
   input wire  cam_reset,   // active high
   output wire sioc, 
   output wire siod_out, 
   output wire sio_n_oe     // active low
   );

   localparam TX_IDLE  = 3'b000;
   localparam TX_ONE   = 3'b001;
   localparam TX_TWO   = 3'b010;
   localparam TX_THREE = 3'b100;

   localparam BIT_IDLE  = 4'b0000;
   localparam BIT_START = 4'b0001;
   localparam BIT_D7    = 4'b0010;
   localparam BIT_D6    = 4'b0011;
   localparam BIT_D5    = 4'b0100;
   localparam BIT_D4    = 4'b0101;
   localparam BIT_D3    = 4'b0110;
   localparam BIT_D2    = 4'b0111;
   localparam BIT_D1    = 4'b1000;
   localparam BIT_D0    = 4'b1001;
   localparam BIT_ACK   = 4'b1010;
   localparam BIT_HOLD  = 4'b1011;
   localparam BIT_STOP  = 4'b1100;

   localparam PHASE_IDLE  = 2'b00;
   localparam PHASE_ONE   = 2'b01;
   localparam PHASE_TWO   = 2'b10;
   localparam PHASE_THREE = 2'b11;
   
   localparam MAIN_IDLE  = 3'h0;
   localparam MAIN_WAIT  = 3'h1;
   localparam MAIN_KICK  = 3'h2;
   localparam MAIN_FETCH = 3'h3;
   localparam MAIN_SEND  = 3'h4;
   localparam MAIN_DONE  = 3'h5;

   localparam DEVICE_ADDRESS = 8'h42; // WRITE
   
   reg [3:0] clock_cnt;
   reg [2:0] tx_state;
   reg [3:0] bit_cnt;
   reg [2:0] main_state;
   reg [7:0] data_reg;
   reg [9:0] wait_cnt;
   reg [1:0] phase_cnt;
   reg [7:0] reg_addr_reg;
   reg [7:0] write_data_reg;
   reg [2:0] pc;
   logic [15:0] com_mem;
   
   reg       sioc, siod_out, sio_n_oe;
   wire      kick;

   always @(posedge clk) begin
      if (rst) begin
         main_state <= MAIN_IDLE;
         reg_addr_reg <= 8'h00;
         write_data_reg <= 8'h00;
         pc <= 3'h0;
      end
      else if (&clock_cnt) begin
         if (main_state == MAIN_IDLE && !cam_reset)
           main_state <= MAIN_WAIT;
         else if (main_state == MAIN_WAIT && (&wait_cnt))
           main_state <= MAIN_FETCH;
         else if (main_state == MAIN_FETCH) begin
            main_state <= MAIN_KICK;
            reg_addr_reg   <= com_mem[15:8];
            write_data_reg <= com_mem[7:0];
            pc <= pc + 1'b1;
            if (com_mem == 16'hffff) // End of table
              main_state <= MAIN_DONE;
            else
              main_state <= MAIN_KICK;
         end
         else if (main_state == MAIN_KICK) begin
            main_state <= MAIN_SEND;
         end
         else if (main_state == MAIN_SEND) begin
            if (phase_cnt == PHASE_IDLE)
              main_state <= MAIN_FETCH;
         end 
      end
   end // always @ (posedge clk)

   assign kick = (main_state == MAIN_KICK);

   always @(posedge clk) begin
      if (rst) 
        wait_cnt <= 10'h000;
      else if (&clock_cnt) begin
         if (main_state == MAIN_WAIT)
           wait_cnt <= wait_cnt + 1'b1;
         else
           wait_cnt <= 10'h000;
      end
   end

   always @(posedge clk) begin
      if (rst) 
        clock_cnt <= 4'h0;
      else 
        clock_cnt <= clock_cnt + 1'b1;
   end
   
   always @(posedge clk) begin
      if (rst)
        tx_state <= TX_IDLE;
      else if (&clock_cnt) begin
         case (tx_state) 
           TX_IDLE:
             if (kick)
               tx_state <= TX_ONE;
           TX_ONE:
             tx_state <= TX_TWO;
           TX_TWO:
             tx_state <= TX_THREE;
           TX_THREE:
             if (bit_cnt == BIT_STOP)
               tx_state <= TX_IDLE;
             else
               tx_state <= TX_ONE;
           default:
             tx_state <= 3'hx;
         endcase
      end
   end


   always @(posedge clk) begin
      if (rst)
        bit_cnt <= BIT_IDLE;
      else if (&clock_cnt) begin
         case (bit_cnt)
           BIT_IDLE:
             if (kick)
               bit_cnt <= BIT_START;
           BIT_ACK:
             if (tx_state == TX_THREE) begin
                if (phase_cnt != PHASE_THREE)
                  bit_cnt <= BIT_D7;
                else
                  bit_cnt <= bit_cnt + 1'b1;
             end
           BIT_STOP:
             if (tx_state == TX_THREE)
               bit_cnt <= BIT_IDLE;
           default:
             if (tx_state == TX_THREE)
               bit_cnt <= bit_cnt + 1'b1;
         endcase
      end
   end 

   always @(posedge clk) begin
      if (rst)
        phase_cnt <= PHASE_IDLE;
      else if (&clock_cnt) begin
         case (phase_cnt)
           PHASE_IDLE:
             if (kick)
               phase_cnt <= PHASE_ONE;
           PHASE_ONE:
             if (bit_cnt == BIT_ACK && tx_state == TX_THREE)
               phase_cnt <= PHASE_TWO;
           PHASE_TWO:
             if (bit_cnt == BIT_ACK && tx_state == TX_THREE)
               phase_cnt <= PHASE_THREE;
           PHASE_THREE:
             if (bit_cnt == BIT_STOP && tx_state == TX_THREE)
               phase_cnt <= PHASE_IDLE;
           default
             phase_cnt <= 2'bxx;
         endcase 
      end 
   end 
   
   always @(posedge clk) begin
      if (rst)
        sioc <= 1'b1;
      else begin
        case (bit_cnt)
          BIT_IDLE:
            sioc <= 1'b1;
          BIT_START:
            if (tx_state == TX_THREE)
              sioc <= 1'b0;
            else
              sioc <= 1'b1;
          BIT_HOLD:
            sioc <= 1'b0;
          BIT_STOP:
            sioc <= 1'b1;
          default:
            if (tx_state == TX_TWO)
              sioc <= 1'b1;
            else
              sioc <= 1'b0;
        endcase
      end
   end

   always @(posedge clk) begin
      if (rst)
        siod_out <= 1'b1;
      else 
        case (bit_cnt)
          BIT_IDLE:
            siod_out <= 1'b1;
          BIT_START:
            if (tx_state == TX_ONE)
              siod_out <= 1'b1;
            else
              siod_out <= 1'b0;
          BIT_HOLD:
            siod_out <= 1'b0;
          BIT_STOP:
            if (tx_state == TX_ONE)
              siod_out <= 1'b0;
            else
              siod_out <= 1'b1;
          BIT_ACK:
            siod_out <= 1'b1;
          default:
            siod_out <= data_reg[7] ;
        endcase
   end

   always @(posedge clk) begin
      if (rst)
        data_reg <= 8'h00;
      else if (&clock_cnt) begin
         if (kick)
           data_reg <= DEVICE_ADDRESS; 
         else if (bit_cnt == BIT_ACK && tx_state == TX_THREE) begin
            if (phase_cnt == PHASE_ONE)
              data_reg <= reg_addr_reg;
            else if (phase_cnt ==PHASE_TWO)
              data_reg <= write_data_reg;
         end
         else if (bit_cnt != BIT_START && tx_state == TX_THREE)
           data_reg <= {data_reg[6:0], 1'b0};
      end
   end

   always @(posedge clk) begin
      if (rst)
        sio_n_oe <= 1'b0;
      else if (clock_cnt == 4'h1) begin
         if (bit_cnt == BIT_D0 && tx_state == TX_THREE)
           sio_n_oe <= 1'b1;
         else if (bit_cnt == BIT_ACK)
           sio_n_oe <= 1'b1;
         else
           sio_n_oe <= 1'b0;
      end
   end 

   always_comb begin
      case (pc) 
        3'h0:    com_mem <= {8'h12, 8'h04}; // COM7: RGB
        3'h1:    com_mem <= {8'h40, 8'hd0}; // COM15 RGB565 
        3'h2:    com_mem <= 16'hffff;       // End of table
        3'h3:    com_mem <= 16'hffff;
        3'h4:    com_mem <= 16'hffff;
        3'h5:    com_mem <= 16'hffff;   
        3'h5:    com_mem <= 16'hffff;
        3'h6:    com_mem <= 16'hffff;
        3'h7:    com_mem <= 16'hffff;
        default: com_mem <= 16'hxxxx;
      endcase
   end
endmodule

`default_nettype wire
